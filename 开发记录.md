# Dify 插件开发记录

## 项目概述
本文档记录 Dify 插件开发过程中的关键步骤、决策和问题解决方案。

## 开发环境
- 操作系统: macOS (Darwin arm64)
- 开发工具: Visual Studio Code, Git
- Dify 插件 CLI 版本: 0.0.1b67

## 开发时间线

### [2024-03-18]
- 初始化插件项目
- 设置基本结构
- 实现基础端点功能
- 配置远程 Git 仓库
- 完成端点基础测试
- 添加 GET 端点支持
- 重构 POST 端点命名，保持一致性
- 更新端点组配置

### [最新更新]
- 实现了完整的 ToolRegistry 系统用于工具注册和执行
- 添加了 JSON-RPC 处理方法，支持 initialize、list_tools 和 call_tool 方法
- 为 GET 端点添加了基础框架，准备实现 SSE 和 HTML 页面支持
- 发现并记录了 GET 端点中的方法缺失问题
- 修复了 JSON-RPC call_tool 方法中的异步事件循环问题
- 确认 JSON-RPC 请求能够到达服务器并开始处理，但响应可能因网关超时而中断

## 功能清单
- [x] 基础端点功能（GET/POST基本方法）
- [x] Dify Workflow 基本集成
- [x] MCP 标准 JSON-RPC 实现（基本功能已完成，initialize和list_tools正常工作）
- [ ] SSE 流式响应支持（框架已添加，需实现具体方法）
- [ ] 认证和安全特性

## 端点实现详情
以下是当前实现的端点详情：

### POST 端点
- **YAML 配置文件**: `difyapp_as_mcp_server_post.yaml`
- **实现类文件**: `difyapp_as_mcp_server_post.py` 
- **类名**: `DifyappAsMcpServerEndpoint`
- **路径**: `/difyapp_as_mcp_server`
- **方法**: POST
- **当前功能**: 
  - 支持基础的 Dify Workflow 调用
  - 实现了 JSON-RPC 处理框架
  - 支持 MCP 标准的 initialize、list_tools 和 call_tool 方法
  - 实现了工具注册和执行系统
  - 解决了异步事件循环冲突问题

### GET 端点
- **YAML 配置文件**: `difyapp_as_mcp_server_get.yaml`
- **实现类文件**: `difyapp_as_mcp_server_get.py`
- **类名**: `DifyappAsMcpServerGetEndpoint`
- **路径**: `/difyapp_as_mcp_server`
- **方法**: GET
- **当前功能**: 
  - 返回基本状态信息
  - 框架已添加 SSE 和 HTML 页面支持，但相关方法尚未实现
  - 存在调用未实现方法的 linter 错误

**注意**: 虽然功能相似，但 POST 端点类名为 `DifyappAsMcpServerEndpoint`，而 GET 端点类名为 `DifyappAsMcpServerGetEndpoint`，命名上存在不一致。

## 当前实现的架构

### 工具注册和执行系统
插件实现了一个完整的工具注册和执行系统，包括：

1. **ToolDef 类**:
   - 封装了工具函数及其元数据
   - 能够自动生成工具 JSON Schema
   - 支持异步执行工具函数
   - 智能处理异步函数，避免事件循环冲突

2. **ToolRegistry 类**:
   - 管理所有已注册的工具
   - 提供装饰器接口用于注册工具
   - 支持列出所有工具和执行指定工具

3. **工具注册示例**:
```python
@tool_registry.tool
async def dify_workflow(title: str, language: str = "English") -> str:
    """执行 Dify workflow 并返回结果
    
    Args:
        title: 要处理的标题或主题
        language: 输出使用的语言 (默认英文)
    """
    # 实现...
```

### 异步执行处理
为了解决事件循环冲突问题，实现了智能的异步处理机制：

```python
def execute(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """执行工具，同步方式处理异步函数"""
    try:
        result = self.func(**args)
        if inspect.iscoroutine(result):
            # 如果是协程，使用已存在的事件循环运行它，而不是创建新的循环
            try:
                # 尝试获取当前事件循环
                loop = asyncio.get_event_loop()
                # 如果事件循环已经运行，直接使用同步方式调用
                if loop.is_running():
                    # 使用一个新进程或线程来运行协程
                    import concurrent.futures
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(lambda: asyncio.run(self.func(**args)))
                        result = future.result()
                else:
                    result = loop.run_until_complete(result)
            except RuntimeError:
                # 如果出现RuntimeError可能是没有事件循环，创建一个新的
                result = asyncio.run(self.func(**args))
        return {"output": result}
    except Exception as e:
        return {"output": f"Error: {str(e)}"}
```

### JSON-RPC 处理
POST 端点支持 JSON-RPC 请求，实现以下方法：

1. **initialize**: 返回服务器信息
   ```json
   {
     "name": "服务器名称",
     "description": "服务器描述",
     "schema_version": "mcp-0.7.0",
     "protocol_version": "0.7.0",
     "server_source": "dify-plugin"
   }
   ```

2. **list_tools**: 返回所有已注册工具的 schema
   ```json
   {
     "tools": [
       {
         "name": "工具名称",
         "description": "工具描述",
         "input_schema": { /*...*/ },
         "output_schema": { /*...*/ }
       }
     ]
   }
   ```

3. **call_tool**: 执行指定工具并返回结果
   - 该方法已修改为非异步方式调用，避免事件循环冲突
   - 可能遇到网关超时问题，需要考虑流式响应或优化工作流速度

## 遇到的问题及解决方案
1. **MCP 请求格式问题**:
   - 描述: 客户端请求格式与服务器期望格式不匹配
   - 解决方案: 调整 JSON 请求格式，将参数封装在 `responseValues` 对象中

2. **模型凭证问题**:
   - 描述: 测试时出现 "Model claude-3-5-sonnet-20241022 credentials is not initialized" 错误
   - 解决方案: 需要在 Dify 应用中正确配置模型凭证

3. **GET 端点缺失方法**:
   - 描述: GET 端点中调用了未实现的 `_handle_sse_connection` 和 `_serve_html_page` 方法
   - 解决方案: 需要实现这些方法，或修改 `_invoke` 方法逻辑

4. **异步事件循环冲突**:
   - 描述: JSON-RPC call_tool 方法执行时报错 "Cannot run the event loop while another loop is running"
   - 解决方案: 
     - 移除显式创建的事件循环 
     - 将异步方法改为同步方法
     - 使用智能机制处理异步函数执行

5. **网关超时问题**:
   - 描述: 执行 call_tool 方法时收到 "error code: 504" 网关超时错误
   - 解决方案:
     - 根据服务器日志确认请求已处理但响应超时
     - 考虑实现 SSE 机制提供流式响应
     - 可以优化工作流处理速度

## API 文档
插件提供以下两类 API：

### 1. 非 MCP 标准 API

这些 API 是当前已实现的简单API，与标准 MCP 协议并行工作。

#### POST Workflow API
- **端点**: `/difyapp_as_mcp_server`
- **方法**: POST
- **请求格式**:
```json
{
  "responseValues": {
    "title": {
      "value": "查询内容"
    },
    "language": {
      "value": "语言选择"
    }
  }
}
```
- **响应格式**:
```json
{
  "status": "success",
  "workflow_response": {
    "data": {
      "outputs": {
        "output": "生成的内容"
      },
      "status": "succeeded"
    }
  }
}
```

#### GET Status API
- **端点**: `/difyapp_as_mcp_server`
- **方法**: GET
- **请求参数**: 支持通过URL查询参数传递
- **响应格式**:
```json
{
  "status": "success",
  "message": "Dify MCP Server is running",
  "app_id": "应用ID",
  "query_params": {
    "param1": "value1",
    "param2": "value2"
  }
}
```

### 2. MCP 标准协议 API
MCP 标准协议 API 遵循 Anthropic 的 MCP 规范，包含以下核心方法：

- **initialize**: 初始化连接并返回服务器信息
  - 已成功实现，测试通过
- **list_tools**: 返回可用工具列表
  - 已成功实现，测试通过
- **call_tool**: 调用特定工具并执行操作
  - 基本框架已实现，请求能到达服务器并处理
  - 存在网关超时问题，需进一步优化

## 测试记录
### 2024-03-18 测试
- **测试用例**: 使用 curl 请求发送标题 "kanye west"，语言 "English"
- **请求命令**: 
```bash
curl -X POST "https://jar8zeuq1rs88qdz.ai-plugin.io/difyapp_as_mcp_server" \
     -H "Content-Type: application/json" \
     -d '{"responseValues": {"title": {"value": "kanye west"}, "language": {"value": "English"}}}'
```
- **测试结果**: 成功，返回了关于 Kanye West 的详细 HTML 内容
- **问题**: 初始测试因模型凭证问题失败，第二次测试成功

### 2024-03-18 GET端点测试
- **测试用例**: 使用 curl 请求获取服务器状态
- **请求命令**:
```bash
curl -X GET "https://jar8zeuq1rs88qdz.ai-plugin.io/difyapp_as_mcp_server?param=test"
```
- **测试结果**: 失败，返回 "Internal Server Error: 'DifyappAsMcpServerGetEndpoint' object has no attribute '_serve_html_page'"
- **问题**: 需要实现GET端点的缺失方法

### [最新] JSON-RPC 方法测试
- **测试用例**: 使用 curl 测试 initialize 和 list_tools 方法
- **请求命令**:
```bash
# 测试 initialize 方法
curl -X POST "https://jar8zeuq1rs88qdz.ai-plugin.io/difyapp_as_mcp_server" \
     -H "Content-Type: application/json" \
     -d '{"jsonrpc": "2.0", "id": "test-123", "method": "initialize", "params": {}}'

# 测试 list_tools 方法
curl -X POST "https://jar8zeuq1rs88qdz.ai-plugin.io/difyapp_as_mcp_server" \
     -H "Content-Type: application/json" \
     -d '{"jsonrpc": "2.0", "id": "test-124", "method": "list_tools", "params": {}}'
```
- **测试结果**:
  - initialize: 成功，返回正确的服务器信息
  - list_tools: 成功，返回已注册工具列表
  - call_tool: 请求能到达服务器且开始处理，但返回网关超时错误

## 部署说明
如何部署和使用该插件:

1. 在 Dify 平台中安装插件
2. 配置插件参数，包括:
   - 应用 ID
   - API 密钥
3. 端点可通过 HTTP 客户端或 MCP 兼容客户端访问

## 未来计划
- 解决网关超时问题，考虑通过以下方式:
  - 优化工作流处理速度
  - 实现SSE机制提供流式响应
  - 调整网关超时设置
- 实现 GET 端点缺失的方法
- 实现 SSE 支持（高优先级）
- 添加认证机制（中优先级）
- 优化错误处理（中优先级）
- 实现说明页面（低优先级）

## 路线图
### Step 1: 实现dify workflow 的基础反向调用
- 描述: 实现dify workflow的基础反向调用功能，确保插件能够正确地与dify workflow进行交互。
- 目标: 完成基础反向调用的实现，确保插件能够在dify workflow中正确运行。
- 状态: ✅ 已完成（基础实现，非MCP标准）

### Step 2: 将反向调用的接口根据mcp开发标准变成符合mcp的协议
- 描述: 根据mcp开发标准，将插件的反向调用接口修改为符合mcp协议的接口，确保插件能够与mcp客户端进行正确的交互。
- 目标: 完成mcp协议接口的修改，确保插件能够与mcp客户端进行正确的交互。
- 状态: ✅ 基本完成（initialize和list_tools已完成，call_tool已解决异步问题但有网关超时）

### Step 3: 添加GET端点支持
- 描述: 添加GET端点支持，允许客户端查询服务器状态和应用信息，为SSE连接做准备。
- 目标: 完成GET端点的实现，为SSE连接提供基础。
- 状态: ✓ 基础框架已完成，存在未实现方法问题

### Step 4: 实现 SSE 流式响应
- 描述: 实现服务器发送事件(SSE)支持，使客户端可以接收流式响应和实时更新。
- 目标: 完成SSE响应的实现，支持MCP客户端的事件订阅功能。
- 状态: 📅 计划中（高优先级，可能是解决网关超时问题的关键）

### Step 5: 实现完整的 JSON-RPC 方法
- 描述: 实现完整的MCP标准JSON-RPC方法，包括initialize, list_tools和call_tool。
- 目标: 确保插件完全符合MCP协议规范，可与Claude等客户端完美交互。
- 状态: ✅ 基本完成（需解决call_tool网关超时问题）

### Step 6: 实现一个webapp（说明书）
- 描述: 实现一个webapp，用于展示插件的使用说明和示例，方便用户快速上手使用插件。
- 目标: 完成webapp的实现，确保用户能够通过webapp快速了解插件的使用方法。
- 状态: 📅 计划中（低优先级）

## 参考资料
- [MCP 协议文档](https://www.anthropic.com/claude/model-context-protocol)
- [Dify 插件开发文档](https://docs.dify.ai/v/zh-hans/advanced/plugin-system)
- [Dify Workflow API 文档](https://docs.dify.ai/v/zh-hans/api-reference/workflow-api) 

